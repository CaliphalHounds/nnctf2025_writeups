# Partial Friend

> Navaja Negra CTF 2025

> 02/10/2025 09:00 CEST - 04/10/2025 11:00 CEST

* Categoría: Criptografía
* Autor: Daysa
* Dificultad: ★
* Etiquetas: RSA, Información parcial

## Descripción
    
    Un "buen" amigo me aseguró que esta implementación de RSA era totalmente segura. 
    "¿Por qué filtrar parte de la clave privada? ¿Cuál es el objetivo de ese leak?" Le pregunté. 

    Él me contestó con una sola palabra: 
    AURA

## Archivos
    
    chall.py

```python
from Crypto.Util.number import getPrime, bytes_to_long


with open("flag.txt", "rb") as file:
    flag = file.read()

e = 17
p = getPrime(1024)
q = getPrime(1024)
n = p*q

phi = (p - 1)*(q - 1)
d = pow(e, -1, phi)
ct = pow(bytes_to_long(flag), e, n)

with open("output.txt", "w") as file:
    file.write(f"e = {str(e)}\n")
    file.write(f"n = {str(n)}\n")
    file.write(f"ct = {str(ct)}\n")
    file.write(f"leak = {str(d % 2**((d.bit_length() // 2) + 10))}\n")
```

    output.txt

```python
e = 17
n = 16717510141443333319671095775156820662310412122538368244917051582835403437676075333792971950239856513863278409396497928176573580508424951836394159307375900797525173872537810487475725853240896216674330327241182388240015379724477830009912599713859774646293108108078715802619002871525705544333080976476181051062766079981623891056315266060268801582160765427550940477175578795479276914665990957530840188063778078705334531281547998061826924337898284485022425496282341883762456452721377012902218178491681719803952653801571852001474648470956160435138104116868484415764267881092474269966442123127717394542436919955201375300773
ct = 1182725836398962590421082827918968266734821373340466791588476296090985508280426759835794777839412012347758054880010258927491689848904805888599908173493468124718876849089492807273014464889456149927981187364269609073972250161212178139641783832747491723701531758883807092743426301458771253788488439873326327542987189171011163014797668825732052249490006520530449020233918458841871994938865852863592691809399021451112312479865821097778267569340699906381526961552587093860969773960498956654593237159756107994951939272290022029122838312474463753800505901529272671003853450336412473966184438607041708375579418866130397920742
leak = 46397159173019129811523301502724029803194688876253565530145024814224346766311930971636447918370101583847662787940417368555124914304874970665587533886960896531337041344057160431126883662819505249022777584544213512654040650985920664581662223489678255985083365215157750352155625894042327953435634279028236250006129
```

## Resolución

Reto de información parcial del sistema de cifrado RSA, en el que conocemos un poco más del 50% de los bits menos significativos de la clave privada $d$.

Este ataque se explica, entre otras fuentes, en un artículo de referencia para ataques de información parcial: [Recovering cryptographic keys from partial information, by example](https://hal.science/hal-03045663/document).

### Explicación del ataque

Cuando $e$ es lo suficientemente pequeño para poder iterar sobre él en un tiempo razonable, la mitad superior de los bits de $d$ se pueden recuperar sin información adicional.

Se considera la siguiente expresión:

$$ed \equiv 1 \mod \phi(n)$$

$$ed \equiv 1 \mod (p - 1)(q - 1)$$

$$ed = 1 + k(n - (p + q) + 1)$$

$$ed = 1 + k(n - (p + q) + 1)$$

$$d = \frac{1}{e} + \frac{kn}{e} - \frac{k(p + q)}{e} + \frac{k}{e}$$

$$d = \frac{kn}{e} - \frac{k(p + q - 1) - 1}{e}$$

Como $p + q \approx \sqrt{n}$, que corresponde a 1024 bits, el componente $\frac{k(p + q - 1) - 1}{e}$ modifica únicamente los bits menos significativos de $d$. Por tanto, los más significativos serán aproximadamente los bits más significativos de $\frac{kn}{e}$.

Además, por definición, $k$ pertenece al intervalo $[1, e - 1]$, por lo que es perfectamente iterable.

```python
from Crypto.Util.number import long_to_bytes
from tqdm import tqdm


e = 17
n = 16717510141443333319671095775156820662310412122538368244917051582835403437676075333792971950239856513863278409396497928176573580508424951836394159307375900797525173872537810487475725853240896216674330327241182388240015379724477830009912599713859774646293108108078715802619002871525705544333080976476181051062766079981623891056315266060268801582160765427550940477175578795479276914665990957530840188063778078705334531281547998061826924337898284485022425496282341883762456452721377012902218178491681719803952653801571852001474648470956160435138104116868484415764267881092474269966442123127717394542436919955201375300773
ct = 1182725836398962590421082827918968266734821373340466791588476296090985508280426759835794777839412012347758054880010258927491689848904805888599908173493468124718876849089492807273014464889456149927981187364269609073972250161212178139641783832747491723701531758883807092743426301458771253788488439873326327542987189171011163014797668825732052249490006520530449020233918458841871994938865852863592691809399021451112312479865821097778267569340699906381526961552587093860969773960498956654593237159756107994951939272290022029122838312474463753800505901529272671003853450336412473966184438607041708375579418866130397920742
leak = 46397159173019129811523301502724029803194688876253565530145024814224346766311930971636447918370101583847662787940417368555124914304874970665587533886960896531337041344057160431126883662819505249022777584544213512654040650985920664581662223489678255985083365215157750352155625894042327953435634279028236250006129

unknown = 1020

for k in range(1, e):
    d_msb = (k*n // e)
    d_msb_bin = bin(d_msb)[2:][:unknown]

    for d_length in range(2044, 2049):
        d = int(d_msb_bin + bin(leak)[2:][-(d_length - unknown):], 2)
        m = long_to_bytes(pow(ct, d, n))

        if b"nnctf" in m:
            print(m)
```

> **flag: nnctf{n3V3r_tRU5T_4_p4rt114l_fr1EnD}**